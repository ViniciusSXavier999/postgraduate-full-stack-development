# 4 ‚Üí MANY TO MANY COM ATRIBUTOS (EMBEDDABLE)

üèÜ Este relacionamento √© uma associa√ß√£o de muitos para muitos

üèÜ A pode estar associada a muitas entidades B e uma entidade B tamb√©m poder estar associada a v√°rias entidades A.


‚ö†Ô∏è Na maioria dos relacionamentos ManyToMany a gente vai precisar criar uma terceira tabela, que ser√° a tabela de conex√£o(@Embeddable).


üèÜ A JPA fornece a anota√ß√£o @Embeddable para declarar que uma classe ser√° incorporada por outras entidades.

A anota√ß√£o `@Embeddable` √© usada em Java, especificamente na **Java Persistence API (JPA)**, para indicar que uma classe pode ser **incorporada (embutida)** em outra entidade como parte do seu mapeamento para o banco de dados.

### Resumo:

- `@Embeddable` √© usada para **marcar uma classe como componente**.
- Ela **n√£o representa uma entidade independente** no banco de dados.
- √â usada em conjunto com a anota√ß√£o `@Embedded` dentro de uma entidade JPA.

### Exemplo simples:

```java
@Embeddable
public class Endereco {
    private String rua;
    private String cidade;
    private String cep;
}

@Entity
public class Cliente {
    @Id
    private Long id;

    @Embedded
    private Endereco endereco;
}

```

Nesse exemplo:

- A classe `Endereco` √© marcada com `@Embeddable`.
- Ela √© usada dentro da entidade `Cliente`, com a anota√ß√£o `@Embedded`.
- Os campos de `Endereco` ser√£o **mapeados como colunas da tabela `Cliente`**, e n√£o em uma tabela separada.

üèÜ Observe no exemplo que ser√° feito o mapeamento dos campos para uma nova entidade.



### MAIS EXEMPLOS DO USO DE EMBEDDABLE

---

### üß© O que √© `@Embeddable`?

`@Embeddable` √© usada para criar **classes incorpor√°veis** (embedded) ‚Äî ou seja, **classes cujos atributos podem ser inclu√≠dos em outras entidades JPA**, sem precisarem ser entidades separadas com seu pr√≥prio `@Id`.

---

## ‚úÖ Exemplo simples de uso

### 1. Classe Embeddable

```java
import jakarta.persistence.Embeddable;

@Embeddable
public class Endereco {
    private String rua;
    private String cidade;
    private String cep;

    // Getters e Setters
}

```

Essa classe **n√£o √© uma entidade**. Ela ser√° **incorporada** em outra entidade.

---

### 2. Classe Entity usando `@Embedded`

```java
import jakarta.persistence.*;

@Entity
public class Cliente {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String nome;

    @Embedded
    private Endereco endereco;

    // Getters e Setters
}

```

---

### üß™ Exemplo de uso no c√≥digo:

```java
Cliente cliente = new Cliente();
cliente.setNome("Jo√£o");

Endereco endereco = new Endereco();
endereco.setRua("Rua A");
endereco.setCidade("S√£o Paulo");
endereco.setCep("01000-000");

cliente.setEndereco(endereco);

entityManager.persist(cliente);

```

---

### üßæ Resultado no banco de dados:

A tabela `Cliente` ter√° colunas:

```
id | nome  | rua   | cidade     | cep
-----------------------------------------
1  | Jo√£o  | Rua A | S√£o Paulo  | 01000-000

```

> Os atributos de Endereco s√£o "embutidos" como colunas da tabela Cliente.
> 

---

Se quiser, posso mostrar tamb√©m como personalizar os nomes das colunas com `@AttributeOverrides`. Deseja isso?

## EXEMPLO:

üèÜ No exemplo abaixo, podemos dizer que um estudante pode avaliar v√°rios cursos e que v√°rios cursos podem ser avaliados por v√°rios estudantes

<img width="600" src = "https://github.com/ViniciusSXavier999/Assets/blob/main/P%C3%B3sGradua%C3%A7%C3%A3o/manyToMany1.png" />


---

### INICIANDO A PR√ÅTICA

üí° Antes vamos alterar algumas coisas no c√≥digo da aula passada 

- Adicionar a anota√ß√£o @Jsonignore no atributo estudante da entidade livro
- Adicionando um loop for no service de atualizar estudante para associar o livro para seu respectivo estudante

```java
	for(Livro livro: estudante.getLivros()) {
				livro.setEstudante(estudante);
			}
```

### EXPLICANDO O C√ìDIGO DETALHADAMENTE

```java
for (Livro livro : estudante.getLivros()) {
    livro.setEstudante(estudante);
}

```

### ‚úÖ **Resumo do que ele faz:**

Esse `for` percorre todos os **livros associados a um estudante**, e para **cada livro**, ele **define o pr√≥prio estudante como dono** (ou associado) desse livro.

### üìå Contexto t√≠pico:

Esse padr√£o √© comum em aplica√ß√µes que usam **JPA/Hibernate**, quando temos um relacionamento **bidirecional** entre entidades, por exemplo:

- Um **Estudante** tem v√°rios **Livros** (`@OneToMany`)
- Cada **Livro** pertence a um **Estudante** (`@ManyToOne`)

Para manter a **consist√™ncia do relacionamento dos dois lados**, precisamos garantir que cada `Livro` tamb√©m "conhe√ßa" o `Estudante` ao qual pertence.

### üß† Por que isso √© importante?

O JPA **n√£o sincroniza automaticamente os dois lados do relacionamento**. Ent√£o, se voc√™ faz s√≥:

```java
estudante.getLivros().add(livro);

```

O `livro` n√£o sabe que pertence ao `estudante`, e isso pode causar inconsist√™ncias no banco ao salvar.

### ‚úÖ Esse loop garante:

- `livro.getEstudante()` vai retornar o `estudante` correto.
- O relacionamento estar√° **totalmente sincronizado** e pronto para ser persistido com JPA.

Se quiser, posso mostrar o modelo completo com JPA para ilustrar melhor.


üí° - E tamb√©m agora √© poss√≠vel cadastrar um estudante sem nenhum livro

```java
	private Set<Livro> livros = new HashSet<>();
```



### INICIANDO A PR√ÅTICA DA AULA ATUAL

### 1. VAMOS COME√áAR CRIANDO UMA NOVA ENTIDADE CHAMADA ‚ÄúAVALIA√á√ÉOCURSO‚Äù

> Essa vai ser a entidade de conex√£o
> 

> Vamos colocar as anota√ß√µes necess√°rias
> 

### 2. DENTRO DESSA TABELA DE CONEX√ÉO, VAMOS CRIAR UM ESTUDANTE E UM CURSO E UM ATRIBUTO ESPECIFICO DESSA CLASSE.

> Vamos anotar o atributo da classe Estudante com a anota√ß√£o @ManyToOne
> 

### A Classe esta assim por enquanto

```java
	
	@ManyToOne
	@MapsId("estudanteId") // faz referencia ao id do estudante
	@JoinColumn(name = "estudante_id")
	private Estudante estudante;
	
	@ManyToOne
	@MapsId("cursoId") // faz referencia ao id do curso
	@JoinColumn(name = "curso_id")
	private Curso curso;
```

### 3. VAMOS CRIAR MAIS UMA CLASSE CHAMADA AVALIACAOCURSOKEY

> Nessa classe vamos fazer refer√™ncia aos IDS de estudante e curso
> 

> O nome tem que ser o mesmo que eu passei na minha classe AvaliacaoCurso
> 

> Essa classe vai ser a chave prim√°ria da minha classe AvaliacaoCurso
> 

```java
@Embeddable
public class AvaliacaoCursoKey implements Serializable{
	
	private static final long serialVesionUID = 1L;
	
	@Column(name = "estudante_id")
	Long estudanteId;
	
	@Column(name = "curso_id")
	Long cursoId;

}

```

### 4. EM SEGUIDA, VAMOS ADICIONAR AVALIACAOCURSOS NA CLASSE ESTUDANTE (VAMOS FAZER O RELACIONAMENTO DE ESTUDANTE COM A TABELA DE CONEX√ÉO)

```java
	@OneToMany(mappedBy = "estudante")
	private Set<AvaliacaoCurso> avaliacaoCursos;
```

---

## D√öVIDAS

### O QUE √â @MAPSID?

üí°  A anota√ß√£o `@MapsId` √© usada para **mapear uma chave prim√°ria composta (composite key)**, especialmente quando **uma entidade compartilha sua chave prim√°ria com outra** (por exemplo, em relacionamentos `@OneToOne` ou `@ManyToOne` onde a FK tamb√©m √© a PK).

---

## üìå O que √© `@MapsId`?

`@MapsId` √© uma anota√ß√£o do JPA usada para **informar que o identificador da entidade atual √© mapeado por um atributo de relacionamento** (normalmente uma entidade pai). Ela √© √∫til para casos em que a chave prim√°ria √© derivada de outra entidade.

---

### ‚úÖ Exemplo pr√°tico:

Imagine duas entidades: `User` e `UserProfile`. Cada `UserProfile` pertence a exatamente um `User`, e o `id` do `UserProfile` **√© o mesmo** que o `id` do `User`.

```java
@Entity
public class User {
    @Id
    private Long id;

    private String name;

    // getters e setters
}

```

```java
@Entity
public class UserProfile {

    @Id
    private Long id;

    @OneToOne
    @MapsId // Diz que o id do UserProfile √© o mesmo do User
    @JoinColumn(name = "id")
    private User user;

    private String bio;

    // getters e setters
}

```

---

### üîç O que isso faz?

- `@MapsId` diz ao JPA que o campo `user` deve fornecer o valor para o campo `id` da entidade `UserProfile`.
- Ou seja, o `UserProfile` n√£o tem seu pr√≥prio ID; ele **reutiliza o ID do `User`**.

---

### üß† Quando usar?

Use `@MapsId` quando:

- Voc√™ tem uma entidade dependente que **compartilha a chave prim√°ria com uma entidade "dona"**.
- Est√° modelando **relacionamentos fortes**, como composi√ß√£o ou entidades dependentes com o mesmo ID.

---


### O QUE √â EMBEDDEDID?

üí° No **Java com JPA/Hibernate**, a anota√ß√£o `@EmbeddedId` √© usada para mapear **chaves prim√°rias compostas** (ou seja, compostas por mais de um campo) em uma entidade.

---

## üìå O que √© `@EmbeddedId`?

`@EmbeddedId` √© usada quando voc√™ deseja definir uma **chave prim√°ria composta como um objeto embutido (embeddable)**. Esse objeto deve ser anotado com `@Embeddable` e conter os campos que comp√µem a chave prim√°ria.

---

### ‚úÖ Exemplo pr√°tico:

### 1. Criando a chave prim√°ria composta com `@Embeddable`:

```java
@Embeddable
public class OrderItemId implements Serializable {

    private Long orderId;
    private Long productId;

    // Construtores, getters, setters, equals() e hashCode()
}

```

### 2. Usando `@EmbeddedId` na entidade principal:

```java
@Entity
public class OrderItem {

    @EmbeddedId
    private OrderItemId id;

    private Integer quantity;

    // Relacionamentos (opcional), getters e setters
}

```

---

### üîç O que acontece aqui?

- `OrderItem` possui uma chave composta por `orderId` e `productId`.
- Esses dois campos est√£o encapsulados dentro de uma classe `OrderItemId`, que √© marcada com `@Embeddable`.
- `@EmbeddedId` diz ao JPA para usar esse objeto como chave prim√°ria da entidade.

---

## üÜö Diferen√ßa entre `@EmbeddedId` e `@IdClass`

- `@EmbeddedId`:
    - Usa **um √∫nico campo objeto** como chave prim√°ria.
    - Mais orientado a objetos, mais limpo.
- `@IdClass`:
    - Define os campos da PK **diretamente na entidade**, e a classe separada serve apenas como "descri√ß√£o".
    - √â mais antigo e menos usado atualmente.

---


### DIFEREN√áA DE MAPSID PARA EMBEDDEDID

üí°  Tanto `@MapsId` quanto `@EmbeddedId` s√£o usados para trabalhar com **chaves prim√°rias compostas** no JPA, mas eles t√™m prop√≥sitos diferentes e funcionam de maneiras distintas.

Vamos comparar de forma clara:

---

## üîπ `@EmbeddedId`

### ‚úÖ Quando usar:

Quando voc√™ quer **modelar uma chave prim√°ria composta** como um **objeto embutido** (com `@Embeddable`), que representa **apenas a chave prim√°ria da entidade**.

### üîß Como funciona:

- A classe `@Embeddable` define os campos da chave composta.
- A entidade usa `@EmbeddedId` para incluir esse objeto como chave prim√°ria.
- Ideal para **entidades com chaves compostas que n√£o s√£o baseadas em relacionamentos fortes**.

### üß© Exemplo:

```java
@Embeddable
public class OrderItemId implements Serializable {
    private Long orderId;
    private Long productId;
}

@Entity
public class OrderItem {
    @EmbeddedId
    private OrderItemId id;

    private Integer quantity;
}

```

---

## üîπ `@MapsId`

### ‚úÖ Quando usar:

Quando voc√™ tem uma entidade que **compartilha a chave prim√°ria com outra entidade relacionada** (geralmente em `@OneToOne` ou `@ManyToOne`), e voc√™ quer mapear esse relacionamento como a **pr√≥pria chave prim√°ria**.

### üîß Como funciona:

- A chave prim√°ria vem de outra entidade relacionada.
- A entidade dependente **n√£o tem seu pr√≥prio ID**; ela **reutiliza** o ID da entidade associada.
- Usa `@MapsId` junto com `@Id` ou `@EmbeddedId`.

### üß© Exemplo:

```java
@Entity
public class User {
    @Id
    private Long id;
}

@Entity
public class UserProfile {
    @Id
    private Long id;

    @OneToOne
    @MapsId // Usa o ID do User como chave prim√°ria
    @JoinColumn(name = "id")
    private User user;
}

```

---

## üìä Resumo da diferen√ßa:

| Caracter√≠stica | `@EmbeddedId` | `@MapsId` |
| --- | --- | --- |
| Prop√≥sito | Chave composta com campos pr√≥prios | Compartilhar ID com outra entidade |
| Classe auxiliar | `@Embeddable` | Opcional (`@Embeddable` s√≥ se usar `@EmbeddedId`) |
| Baseada em relacionamento | ‚ùå N√£o necessariamente | ‚úÖ Sim (precisa de um relacionamento) |
| Onde est√° o ID | Em um objeto embutido | Em uma entidade relacionada |
| Exemplo t√≠pico | Tabelas com chave composta simples | Entidades com depend√™ncia forte (composi√ß√£o) |

---

