# 4 ‚Üí CRIANDO O CONTROLLER

üèÜ O nosso controller ter√° dois end-points: 

- UPLOAD DE ARQUIVOS
- DOWNLOAD DE ARQUIVOS

---

### 1. PRIMEIRA COISA QUE VAMOS FAZER √â CRIAR A NOSSA CLASSE CONTROLLER E COLOCAR AS DEVIDAS ANOTA√á√ïES NECESS√ÅRIAS

### 2. VAMOS CRIAR OS M√âTODOS PARA UPLOAD E DOWNLOAD

### M√âTODO UPLOAD ARQUIVO

```java
@PostMapping("upload")
	public Arquivo uploadArquivo(@RequestParam("file") MultipartFile file) {
		String nomeArquivo = arquivoService.salvarArquivo(file);
		
		String caminhoArquivo = ServletUriComponentsBuilder.fromCurrentContextPath()
				.path("/arquivos/downloadArquivo")
				.path(nomeArquivo).toUriString();
		
		return new Arquivo(nomeArquivo, caminhoArquivo, file.getContentType(), file.getSize());
	}
```

üîí

### EXPLICANDO O ENDPOINT UPLOAD

---

### üì¶ C√≥digo completo:

```java
@PostMapping("upload")
public Arquivo uploadArquivo(@RequestParam("file") MultipartFile file) {
    String nomeArquivo = arquivoService.salvarArquivo(file);

    String caminhoArquivo = ServletUriComponentsBuilder.fromCurrentContextPath()
        .path("/arquivos/downloadArquivo")
        .path(nomeArquivo).toUriString();

    return new Arquivo(nomeArquivo, caminhoArquivo, file.getContentType(), file.getSize());
}

```

---

### üß† Explica√ß√£o linha por linha:

---

```java
@PostMapping("upload")

```

üîπ Define que este m√©todo ser√° chamado quando o cliente fizer um **POST para a URL `/upload`**.

üîπ Geralmente, isso acontece quando um formul√°rio com envio de arquivos (`multipart/form-data`) √© submetido, ou via chamada HTTP com biblioteca tipo Postman, Axios, etc.

---

```java
public Arquivo uploadArquivo(@RequestParam("file") MultipartFile file) {

```

üîπ Define o m√©todo `uploadArquivo`, que:

- Retorna um objeto `Arquivo` (provavelmente uma classe modelo que voc√™ criou para descrever o arquivo salvo).
- Recebe um par√¢metro `file`, que √© o **arquivo enviado pelo cliente**.

üîπ `@RequestParam("file")`:

- Indica que o arquivo deve vir de um campo chamado `file` (como `<input type="file" name="file">`).
- `MultipartFile` √© uma classe do Spring que representa arquivos enviados via formul√°rio.

---

```java
String nomeArquivo = arquivoService.salvarArquivo(file);

```

üîπ Chama o m√©todo `salvarArquivo()` de um **servi√ßo chamado `arquivoService`** (provavelmente voc√™ j√° viu ou criou esse m√©todo).

üîπ Esse m√©todo:

- Salva o arquivo no servidor
- Retorna o **nome do arquivo salvo** (como `"foto123.png"`)

---

```java
String caminhoArquivo = ServletUriComponentsBuilder.fromCurrentContextPath()
    .path("/arquivos/downloadArquivo")
    .path(nomeArquivo).toUriString();

```

üîπ Monta a **URL p√∫blica de acesso ao arquivo**, por exemplo:

```
http://localhost:8080/arquivos/downloadArquivo/foto123.png

```

üîπ Linha por linha:

- `fromCurrentContextPath()` ‚Üí pega o caminho atual da aplica√ß√£o (`http://localhost:8080`)
- `.path(...)` ‚Üí adiciona o endpoint onde o arquivo pode ser baixado
- `.path(nomeArquivo)` ‚Üí junta o nome do arquivo
- `.toUriString()` ‚Üí transforma tudo em uma `String` com a URL completa

---

```java
return new Arquivo(nomeArquivo, caminhoArquivo, file.getContentType(), file.getSize());

```

üîπ Cria e retorna um objeto `Arquivo`, que provavelmente √© uma **classe modelo** com esses atributos:

| Atributo | Valor |
| --- | --- |
| `nomeArquivo` | Nome do arquivo salvo (`"foto123.png"`) |
| `caminhoArquivo` | URL p√∫blica para baixar o arquivo |
| `file.getContentType()` | Tipo do arquivo (ex: `image/png`, `application/pdf`) |
| `file.getSize()` | Tamanho do arquivo em bytes |

---

### üßæ Classe `Arquivo` (exemplo prov√°vel):

```java
public class Arquivo {
    private String nome;
    private String url;
    private String tipo;
    private long tamanho;

    public Arquivo(String nome, String url, String tipo, long tamanho) {
        this.nome = nome;
        this.url = url;
        this.tipo = tipo;
        this.tamanho = tamanho;
    }

    // Getters e setters (ou use Lombok)
}

```

---

### üìå Exemplo pr√°tico com Postman:

- M√©todo: `POST`
- URL: `http://localhost:8080/upload`
- Tipo de Body: `form-data`
- Campo: `file` (tipo "File") ‚Üí selecione um arquivo qualquer

---


üí°

### @REQUESTPARAM

### ‚úÖ O que √© `@RequestParam`?

`@RequestParam` serve para **ligar um par√¢metro da requisi√ß√£o HTTP** (como query string ou formul√°rio) a um **par√¢metro do m√©todo no controller**.

---

### üì¶ Exemplo 1: Pegando da URL (Query Parameter)

Se voc√™ acessar a URL:

```
http://localhost:8080/saudacao?nome=Joao

```

Voc√™ pode capturar esse valor assim:

```java
@GetMapping("/saudacao")
public String saudacao(@RequestParam String nome) {
    return "Ol√°, " + nome + "!";
}

```

üîπ Aqui, o valor de `nome` na URL (`Joao`) √© automaticamente passado para o par√¢metro `String nome`.

---

### ‚öôÔ∏è Com mais op√ß√µes

```java
@GetMapping("/produto")
public String getProduto(@RequestParam(name = "id", required = false, defaultValue = "0") int id) {
    return "Produto com ID: " + id;
}

```

- `name = "id"` ‚Üí nome do par√¢metro na URL
- `required = false` ‚Üí n√£o √© obrigat√≥rio
- `defaultValue = "0"` ‚Üí se n√£o for informado, ser√° 0

---

### üìù Exemplo 2: Envio por formul√°rio (POST)

```html
<form action="/enviar" method="post">
    <input type="text" name="mensagem">
    <button type="submit">Enviar</button>
</form>

```

E no controller:

```java
@PostMapping("/enviar")
public String receber(@RequestParam String mensagem) {
    return "Voc√™ enviou: " + mensagem;
}

```

---

### üÜö Diferen√ßa entre `@RequestParam`, `@PathVariable` e `@RequestBody`

| Anota√ß√£o | Vem de onde? | Exemplo de uso |
| --- | --- | --- |
| `@RequestParam` | Query String ou formul√°rio | `/produto?id=10` |
| `@PathVariable` | Parte da URL | `/produto/10` |
| `@RequestBody` | Corpo da requisi√ß√£o (JSON, etc.) | Envio de dados complexos via POST (ex: JSON) |

---


### M√âTODO DOWNLOAD ARQUIVO

```java
@GetMapping("/downloadArquivo/{nomeArquivo}")
	public ResponseEntity<Resource> downloadArquivo(@PathVariable String nomeArquivo, HttpServletRequest request) {
		
		
		Resource resource = arquivoService.carregarArquivo(nomeArquivo);
		
		// descobringo o tipo do arquivp
		String contentType = arquivoService.getContentType(request, resource);
		
		// agora vamos fazer o download do arquivo
		
		return ResponseEntity.ok()
				// Esse √© um padr√£o para transfer√™ncia e download de arquivo
				.contentType(MediaType.parseMediaType(contentType))
				.header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + resource.getFilename() + "\"")
				.body(resource);
	}
```

üîí

### EXPLICA√á√ÉO DO C√ìDIGO PASSO A PASSO

### ‚úÖ Vis√£o geral

Este m√©todo:

1. Recebe o **nome de um arquivo**
2. Busca esse arquivo no servidor
3. Descobre o tipo (MIME type)
4. Prepara a resposta com os **headers corretos para download**
5. Retorna o arquivo como resposta HTTP

---

### üì¶ C√≥digo explicado:

```java
@GetMapping("/downloadArquivo/nomeArquivo")

```

üîπ Indica que esse m√©todo ser√° acessado via **GET** na rota `/downloadArquivo/nomeArquivo`.

‚ùóÔ∏è**Problema aqui:** a URL tem `nomeArquivo` como **fixo**, quando o correto seria us√°-lo como vari√°vel de caminho:

‚úÖ O certo seria:

```java
@GetMapping("/downloadArquivo/{nomeArquivo}")

```

Assim, voc√™ pode passar o nome real do arquivo na URL, ex: `/downloadArquivo/foto123.png`

---

```java
public ResponseEntity<Resource> downloadArquivo(String nomeArquivo, HttpServletRequest request) {

```

üîπ M√©todo que:

- Retorna um `ResponseEntity<Resource>` (um arquivo dentro da resposta HTTP)
- Recebe:
    - `String nomeArquivo` ‚Üí o nome do arquivo a ser baixado
    - `HttpServletRequest request` ‚Üí para acessar informa√ß√µes da requisi√ß√£o HTTP (como o `User-Agent`, etc.)

‚ùóÔ∏è**Nota:** Para que `nomeArquivo` funcione com a URL, ele precisa da anota√ß√£o:

```java
@PathVariable String nomeArquivo

```

‚úÖ Correto:

```java
public ResponseEntity<Resource> downloadArquivo(@PathVariable String nomeArquivo, HttpServletRequest request)

```

---

```java
Resource resource = arquivoService.carregarArquivo(nomeArquivo);

```

üîπ Chama um servi√ßo (`arquivoService`) que tenta **carregar o arquivo** com o nome fornecido.

üîπ O retorno √© um `Resource` ‚Äî um tipo que representa um arquivo ou recurso externo no Spring.

---

```java
String contentType = arquivoService.getContentType(request, resource);

```

üîπ Esse m√©todo tenta descobrir o **tipo MIME** do arquivo (como `image/png`, `application/pdf`, etc.).

üîπ Usa o `HttpServletRequest` e o pr√≥prio arquivo (`Resource`) para identificar o tipo.

üîπ Isso ajuda o navegador a **entender como lidar com o arquivo** (abrir ou baixar, por exemplo).

---

```java
return ResponseEntity.ok()

```

üîπ Inicia a cria√ß√£o de uma resposta HTTP com status **200 OK**.

---

```java
    .contentType(MediaType.parseMediaType(contentType))

```

üîπ Define o cabe√ßalho `Content-Type` com o **tipo real do arquivo**, garantindo que o navegador saiba como trat√°-lo corretamente.

---

```java
    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + resource.getFilename() + "\"")

```

üîπ Define o cabe√ßalho `Content-Disposition` como `"attachment"`:

- Isso **for√ßa o navegador a baixar o arquivo**, em vez de tentar abrir direto.
- O nome do arquivo usado no download √© o mesmo do arquivo original (`resource.getFilename()`)

---

```java
    .body(resource);

```

üîπ Define o **corpo da resposta** como o conte√∫do do arquivo.

‚úîÔ∏è Com isso, o Spring entrega o arquivo diretamente ao navegador ou cliente.

---

### üßæ Exemplo completo corrigido:

```java
@GetMapping("/downloadArquivo/{nomeArquivo}")
public ResponseEntity<Resource> downloadArquivo(
        @PathVariable String nomeArquivo,
        HttpServletRequest request) {

    Resource resource = arquivoService.carregarArquivo(nomeArquivo);

    String contentType = arquivoService.getContentType(request, resource);

    return ResponseEntity.ok()
            .contentType(MediaType.parseMediaType(contentType))
            .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + resource.getFilename() + "\"")
            .body(resource);
}

```

---

### üì• Exemplo de uso (navegador ou Postman):

Se voc√™ salvou o arquivo `"relatorio.pdf"`, pode acessar:

```
GET http://localhost:8080/downloadArquivo/relatorio.pdf

```

E ele ser√° baixado automaticamente com os headers corretos.

---


---

### O QUE √â A CLASSE HttpServletRequest?

üèÜ

Excelente pergunta! A classe `HttpServletRequest` √© **uma das mais importantes** quando voc√™ trabalha com aplica√ß√µes web em Java usando Servlets, Spring MVC ou Spring Boot.

---

## ‚úÖ O que √© `HttpServletRequest`?

A classe `HttpServletRequest` representa a **requisi√ß√£o HTTP feita pelo cliente** (como um navegador, Postman, ou outro sistema) para o servidor.

Ela cont√©m **todas as informa√ß√µes da requisi√ß√£o**, como:

- Par√¢metros da URL (query string)
- Dados do formul√°rio (em POST)
- Cabe√ßalhos HTTP (headers)
- Informa√ß√µes sobre cookies
- IP do cliente
- Tipo do navegador (User-Agent)
- Caminho da URL acessada
- Corpo da requisi√ß√£o
- Sess√£o do usu√°rio

---

## üì¶ De onde ela vem?

Ela faz parte da especifica√ß√£o do **Servlet API**, do pacote:

```java
import jakarta.servlet.http.HttpServletRequest;
// ou em vers√µes antigas:
import javax.servlet.http.HttpServletRequest;

```

> Em projetos Spring Boot, ela √© passada automaticamente como par√¢metro nos m√©todos do controller, caso voc√™ precise acessar dados da requisi√ß√£o diretamente.
> 

---

## üõ† Exemplos pr√°ticos

### üîπ Obter IP do cliente:

```java
String ip = request.getRemoteAddr();

```

### üîπ Obter o User-Agent (navegador ou app que fez a requisi√ß√£o):

```java
String userAgent = request.getHeader("User-Agent");

```

### üîπ Pegar um par√¢metro da URL (ex: ?nome=joao):

```java
String nome = request.getParameter("nome");

```

### üîπ Pegar o caminho completo da URL:

```java
String url = request.getRequestURL().toString();

```

---

## ‚úÖ Quando usar no Spring?

Voc√™ s√≥ precisa usar `HttpServletRequest` **quando quiser acessar dados mais "baixos" ou espec√≠ficos** da requisi√ß√£o, que o Spring normalmente j√° trataria automaticamente com anota√ß√µes como `@RequestParam`, `@RequestHeader`, etc.

### üìå Exemplo real no Spring:

```java
@GetMapping("/info")
public String info(HttpServletRequest request) {
    String ip = request.getRemoteAddr();
    String userAgent = request.getHeader("User-Agent");

    return "IP: " + ip + ", Navegador: " + userAgent;
}

```

---


### O QUE √â SERVLET?

---

## ‚úÖ O que √© um **Servlet**?

Um **Servlet** √© um **objeto Java** que roda dentro de um **servidor web** (como Tomcat) e √© respons√°vel por **receber e responder requisi√ß√µes HTTP**.

üëâ Ele √© a **base de toda aplica√ß√£o web em Java** tradicional.

Tudo que voc√™ v√™ hoje em **Spring Boot**, por exemplo, por baixo dos panos ainda depende de Servlets.

---

### üì¶ Em termos simples:

Um Servlet √© como uma **classe Java que entende HTTP**.

Voc√™ escreve um c√≥digo que:

- Recebe uma requisi√ß√£o (ex: um formul√°rio enviado)
- Processa dados (ex: salva no banco)
- E responde (ex: "Usu√°rio salvo com sucesso")

---

### üß† Como funciona o ciclo:

1. O navegador ou app envia uma requisi√ß√£o HTTP (ex: `GET /usuarios`)
2. O servidor (Tomcat, Jetty, etc.) **entrega essa requisi√ß√£o para o Servlet**
3. O Servlet processa a requisi√ß√£o (`HttpServletRequest`)
4. O Servlet gera uma resposta (`HttpServletResponse`)
5. A resposta √© enviada de volta para o cliente (HTML, JSON, etc.)

---

### üß™ Exemplo b√°sico de Servlet:

```java
@WebServlet("/hello")
public class HelloServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
            throws IOException {
        resp.setContentType("text/plain");
        resp.getWriter().write("Ol√°, mundo!");
    }
}

```

üîπ Isso cria um endpoint em `/hello` que responde com "Ol√°, mundo!"

üîπ `doGet()` √© chamado quando a requisi√ß√£o √© do tipo GET

---

## üöÄ E o Spring? Usa Servlet?

**Sim!** Mas o Spring te **abstrai** de toda essa complexidade.

Por exemplo, este c√≥digo no Spring:

```java
@GetMapping("/hello")
public String hello() {
    return "Ol√°, mundo!";
}

```

üëâ Internamente o Spring est√° registrando um Servlet, tratando requisi√ß√£o e resposta, tudo **sem voc√™ precisar fazer isso manualmente**.

---

## üß± Tipos de Servlet:

- **HttpServlet** ‚Üí mais comum, usado para requisi√ß√µes HTTP
- **GenericServlet** ‚Üí base mais gen√©rica (raro de usar diretamente)

---

### üìå Resumo:

| Termo | Significado |
| --- | --- |
| **Servlet** | Classe Java que responde a requisi√ß√µes web |
| **HttpServlet** | Subclasse especializada para HTTP |
| **Servlet Container** | Servidor que executa os servlets (ex: Tomcat) |
| **Spring** | Usa servlets por baixo dos panos, mas simplifica tudo |

---