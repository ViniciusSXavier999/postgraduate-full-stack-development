# 3 ‚Üí DEPENDENCY INVERSION PRINCIPLE

### DEFINI√á√ïES QUE ABORDAM ESSA QUEST√ÉO

### FRASE 01

üèÜ O Princ√≠pio de invers√£o de depend√™ncia √© a estrat√©gia de depender de interfaces ou fun√ß√µes e classes abstratas, em vez de fun√ß√µes e classes concretas.

### O que √© classe concreta?

Classes **concretas** s√£o classes **completas**, que **podem ser instanciadas** (ou seja, voc√™ pode criar objetos a partir delas).

---

### ‚úÖ Resumo r√°pido:

- **Classe concreta**: tem **implementa√ß√µes reais** dos m√©todos.
- **Voc√™ pode criar objetos** com `new MinhaClasse()`.

---

### üß± Exemplo:

```java
public class Carro {
    void ligar() {
        System.out.println("Carro ligado");
    }
}

```

Aqui, `Carro` √© uma **classe concreta**. Voc√™ pode fazer:

```java
Carro c = new Carro();
c.ligar();

```

---

### ‚ùå Contraste com:

- **Classe abstrata**: n√£o pode ser instanciada diretamente.
- **Interface**: define apenas o que as classes devem fazer, n√£o como.

---


### FRASE 02

üèÜ Os m√≥dulos superiores dependem de m√≥dulos dos m√≥dulos de n√≠vel inferior, que dependem de m√≥dulos de n√≠vel ainda inferior, etc

### ‚úÖ Explica√ß√£o resumida:

> Em um sistema mal projetado, m√≥dulos mais "importantes" (n√≠vel alto) dependem diretamente de detalhes de implementa√ß√£o (n√≠vel baixo).
> 

---

### üß† O que o **DIP** diz?

> Inverta essa depend√™ncia!
> 
> 
> Os m√≥dulos de alto n√≠vel **n√£o devem depender de m√≥dulos de baixo n√≠vel**, **ambos devem depender de abstra√ß√µes** (interfaces ou classes abstratas).
> 

---

### üîß Exemplo simples:

---

## üì¶ Cen√°rio simples: **Notifica√ß√£o de usu√°rio**

Queremos que uma classe envie notifica√ß√µes. Podemos ter notifica√ß√µes por **e-mail**, **SMS**, etc.

---

### ‚ùå Sem DIP (errado): classe de alto n√≠vel depende diretamente da implementa√ß√£o concreta

```java
class Email {
    public void enviarMensagem(String msg) {
        System.out.println("Enviando por e-mail: " + msg);
    }
}

class Notificador {
    private Email email = new Email(); // DEPEND√äNCIA DIRETA

    public void notificar(String msg) {
        email.enviarMensagem(msg);
    }
}

```

üö´ Problema: se quisermos trocar `Email` por `SMS`, temos que **mudar o c√≥digo da classe `Notificador`**.

---

### ‚úÖ Com DIP (correto): alto e baixo n√≠vel dependem de **uma abstra√ß√£o**

```java
// Abstra√ß√£o (interface)
interface EnviadorMensagem {
    void enviarMensagem(String msg);
}

// Implementa√ß√£o 1: Email
class EnviadorEmail implements EnviadorMensagem {
    public void enviarMensagem(String msg) {
        System.out.println("Enviando por e-mail: " + msg);
    }
}

// Implementa√ß√£o 2: SMS
class EnviadorSMS implements EnviadorMensagem {
    public void enviarMensagem(String msg) {
        System.out.println("Enviando por SMS: " + msg);
    }
}

// Classe de alto n√≠vel depende da INTERFACE
class Notificador {
    private EnviadorMensagem enviador;

    // Injetamos a depend√™ncia por construtor
    public Notificador(EnviadorMensagem enviador) {
        this.enviador = enviador;
    }

    public void notificar(String msg) {
        enviador.enviarMensagem(msg);
    }
}

```

### üß™ Como usar:

```java
public class Main {
    public static void main(String[] args) {
        EnviadorMensagem enviador = new EnviadorEmail(); // ou new EnviadorSMS()
        Notificador notificador = new Notificador(enviador);

        notificador.notificar("Sua pizza saiu para entrega!");
    }
}

```

---

### ‚úÖ O que est√° acontecendo aqui?

- `Notificador` depende da **interface** `EnviadorMensagem`, n√£o de `Email` ou `SMS` diretamente.
- Podemos mudar a forma de envio **sem tocar no c√≥digo do `Notificador`**.
- Isso √© o DIP em a√ß√£o.

---


---

### IMAGEM QUE REPRESENTA ESSE ASPECTO QUE ESTAMOS ABORDANDO

<img width="600" src = "https://github.com/ViniciusSXavier999/Assets/blob/main/P%C3%B3sGradua%C3%A7%C3%A3o/dependencyInversionPrinciple1.png" />

---

üèÜ Os m√≥dulos de alto n√≠vel lidam com as pol√≠ticas de alto n√≠vel do aplicativo. Essas pol√≠ticas geralmente se preocupam pouco com os detalhes que os implementam.

> Essas especifica√ß√µes devem ficar nas classes inferiores.
> 

---

### M√ÉO NA MASSA!!!

### CLASSE LIVRO

```java
package refatoracao.estudos.solid.dependency.inversion.principle;

public class Livro {
	
	   public void comentarioLivro() {
	        System.out.println("Comentando sobre o livro...");
	    }

	    public void paginaInicialLivro() {
	        System.out.println("Abrindo a primeira p√°gina...");
	    }

}

```

### CLASSE PRATELEIRA

```java
package refatoracao.estudos.solid.dependency.inversion.principle;

public class Prateleira {
	
	 	Livro livro;

	    public Prateleira(Livro livro) {
	        this.livro = livro;
	    }
	    
	    

	    public void addLivro() {
	        System.out.println("Livro adicionado √† prateleira.");
	    }

	    public void customizarComentarios() {
	        livro.comentarioLivro();
	        System.out.println("Coment√°rios personalizados.");
	    }

}
```



ESSA CLASSE DEPENDE DA CLASSE LIVRO DE BAIXO N√çVEL. üèÜ

A classe `Prateleira` **n√£o segue o princ√≠pio da invers√£o de depend√™ncia (Dependency Inversion Principle - DIP)** porque **ela depende diretamente de uma classe concreta (`Livro`) em vez de depender de uma abstra√ß√£o (como uma interface ou classe abstrata)**.

### Relembrando o que diz o DIP:

O **Princ√≠pio da Invers√£o de Depend√™ncia** (a letra "D" do SOLID) afirma que:

> "M√≥dulos de alto n√≠vel n√£o devem depender de m√≥dulos de baixo n√≠vel. Ambos devem depender de abstra√ß√µes. Abstra√ß√µes n√£o devem depender de detalhes. Detalhes devem depender de abstra√ß√µes."
> 

---

### An√°lise do c√≥digo:

```java
public class Prateleira {

 	Livro livro;

 	public Prateleira(Livro livro) {
        this.livro = livro;
    }

    public void addLivro() {
        System.out.println("Livro adicionado √† prateleira.");
    }

    public void customizarComentarios() {
        livro.comentarioLivro(); // <- AQUI est√° a depend√™ncia concreta
        System.out.println("Coment√°rios personalizados.");
    }

}

```

Aqui, a classe `Prateleira` √© um **m√≥dulo de alto n√≠vel**, e a classe `Livro` √© um **m√≥dulo de baixo n√≠vel**. O problema √© que a classe `Prateleira` est√° diretamente acoplada a `Livro`. Isso **viola o DIP**, porque qualquer mudan√ßa na implementa√ß√£o de `Livro` pode impactar diretamente a `Prateleira`.

---

### Como corrigir e seguir o DIP?

Voc√™ pode criar uma **interface** (ou classe abstrata), por exemplo `Publicacao`, e fazer com que `Livro` a implemente. A classe `Prateleira` ent√£o dependeria da **abstra√ß√£o**, n√£o da implementa√ß√£o concreta:

```java
public interface Publicacao {
    void comentarioLivro();
}

```

```java
public class Livro implements Publicacao {
    public void comentarioLivro() {
        System.out.println("Coment√°rio do livro.");
    }
}

```

```java
public class Prateleira {

    private final Publicacao publicacao;

    public Prateleira(Publicacao publicacao) {
        this.publicacao = publicacao;
    }

    public void addLivro() {
        System.out.println("Publica√ß√£o adicionada √† prateleira.");
    }

    public void customizarComentarios() {
        publicacao.comentarioLivro(); // agora √© uma abstra√ß√£o
        System.out.println("Coment√°rios personalizados.");
    }
}

```

---

### Benef√≠cios dessa mudan√ßa:

- **Baixo acoplamento**: `Prateleira` n√£o se importa se √© um `Livro`, `Revista`, ou outro tipo de publica√ß√£o.
- **Alta coes√£o** e **flexibilidade**: facilita testes e manuten√ß√£o.
- **Extensibilidade**: voc√™ pode criar novas classes que implementem `Publicacao` sem alterar `Prateleira`.

---

### EXPLICA√á√ÉO DO C√ìDIGO üèÜ

Nesse c√≥digo, a classe `Prateleira` foi refatorada para seguir o **Princ√≠pio da Invers√£o de Depend√™ncia (DIP)**, e o que est√° acontecendo pode ser explicado passo a passo:

---

### üìå Explica√ß√£o geral

A classe `Prateleira` agora **depende de uma abstra√ß√£o** chamada `Publicacao` (provavelmente uma interface ou classe abstrata), em vez de depender diretamente de uma implementa√ß√£o concreta como `Livro`.

---

### üîç Linha por linha

```java
public class Prateleira {

    private final Publicacao publicacao;

```

- Aqui, `Prateleira` declara um atributo privado chamado `publicacao`, do tipo `Publicacao` (uma **abstra√ß√£o**).
- A palavra-chave `final` indica que esse campo n√£o pode ser reatribu√≠do ap√≥s o construtor. Isso favorece **imutabilidade** e **design seguro**.

---

```java
    public Prateleira(Publicacao publicacao) {
        this.publicacao = publicacao;
    }

```

- A inje√ß√£o de depend√™ncia ocorre aqui: a abstra√ß√£o `Publicacao` √© **injetada via construtor**.
- Isso significa que quem for criar uma inst√¢ncia de `Prateleira` deve fornecer uma implementa√ß√£o de `Publicacao` (por exemplo, um `Livro` que implementa essa interface).

---

```java
    public void addLivro() {
        System.out.println("Publica√ß√£o adicionada √† prateleira.");
    }

```

- M√©todo simples que simula a adi√ß√£o de uma publica√ß√£o √† prateleira.
- A mensagem foi gen√©rica ("Publica√ß√£o", n√£o "Livro") para refletir o uso de abstra√ß√£o.

---

```java
    public void customizarComentarios() {
        publicacao.comentarioLivro(); // agora √© uma abstra√ß√£o
        System.out.println("Coment√°rios personalizados.");
    }

```

- Este m√©todo chama o m√©todo `comentarioLivro()` da interface `Publicacao`.
- Aqui est√° a principal vantagem: `Prateleira` **n√£o sabe qual √© a implementa√ß√£o concreta** ‚Äî ela s√≥ sabe que existe um comportamento (`comentarioLivro()`), e **confia** que quem implementa `Publicacao` fornecer√° esse comportamento.

---

### ‚úÖ O que est√° sendo feito corretamente?

- **Invers√£o de depend√™ncia**: `Prateleira` depende da interface `Publicacao`, n√£o de `Livro`.
- **Desacoplamento**: `Prateleira` pode trabalhar com qualquer tipo de `Publicacao` (ex: `Livro`, `Revista`, `Artigo`, etc.).
- **Facilidade de teste**: voc√™ pode criar uma classe mock (fict√≠cia) de `Publicacao` para testar a `Prateleira`, sem depender de l√≥gica real de `Livro`.

---

### üìò Resumo

Essa vers√£o da classe `Prateleira`:

| Caracter√≠stica | Antes | Agora |
| --- | --- | --- |
| Tipo de depend√™ncia | Concreta (`Livro`) | Abstrata (`Publicacao`) |
| Acoplamento | Alto | Baixo |
| Flexibilidade | Baixa (s√≥ funciona com `Livro`) | Alta (pode funcionar com qualquer `Publicacao`) |
| Conformidade com DIP (SOLID) | ‚ùå N√£o segue | ‚úÖ Segue |



### EXPLICA√á√ÉO DA INJE√á√ÉO DE DEPEND√äNCIA üèÜ

### üß† O que √© inje√ß√£o de depend√™ncia?

**Inje√ß√£o de depend√™ncia (DI)** √© quando um **objeto externo fornece as depend√™ncias** que uma classe precisa, em vez da pr√≥pria classe cri√°-las diretamente.

---

### ‚úÖ No seu exemplo:

```java
public class Prateleira {
    Livro livro;

    public Prateleira(Livro livro) {
        this.livro = livro;
    }
    // ...
}

```

### üîç O que est√° acontecendo aqui?

- A classe `Prateleira` **depende de um objeto `Livro`** para funcionar.
- **Essa depend√™ncia √© passada de fora**, via **construtor** ‚Üí isso √© **inje√ß√£o de depend√™ncia por construtor**.
- Ou seja, **`Prateleira` n√£o cria o `Livro`**, ela apenas **recebe**.

---

### üí¨ Em outras palavras:

> A classe n√£o √© respons√°vel por criar suas depend√™ncias, ela s√≥ as usa.
> 
> 
> Isso segue o **Princ√≠pio da Invers√£o de Depend√™ncia (DIP)**.
> 

---

### ‚úÖ Benef√≠cios:

- C√≥digo mais **flex√≠vel** e **test√°vel**.
- Facilita a **substitui√ß√£o** do `Livro` por outra implementa√ß√£o, se `Livro` fosse uma interface, por exemplo.
- Ajuda a manter o **baixo acoplamento** entre as classes.

---

```java
public class Prateleira {
    Livro livro;

    public Prateleira(Livro livro) {
        this.livro = livro;
    }
    // ...
}

```

A **instancia√ß√£o do objeto `Livro` n√£o ocorre dentro da classe `Prateleira`**. Ou seja, a classe `Prateleira` **recebe** um objeto do tipo `Livro` de **fora** ‚Äì isso **√© um exemplo de inje√ß√£o de depend√™ncia via construtor**.

---

### Onde ocorre a instancia√ß√£o ent√£o?

A **instancia√ß√£o ocorre fora da classe `Prateleira`**, por exemplo:

```java
Livro meuLivro = new Livro();           // AQUI ocorre a instancia√ß√£o
Prateleira prateleira = new Prateleira(meuLivro);  // Inje√ß√£o da depend√™ncia

```

Nesse caso, o objeto `Livro` √© criado fora e **injetado no construtor** da classe `Prateleira`.

---

### Se fosse sem inje√ß√£o de depend√™ncia, seria assim:

```java
public class Prateleira {
    Livro livro;

    public Prateleira() {
        this.livro = new Livro(); // AQUI ocorre a instancia√ß√£o internamente
    }
}

```

Nesse caso, `Prateleira` cria a inst√¢ncia de `Livro` sozinha ‚Äî isso **aumenta o acoplamento** e dificulta testes e manuten√ß√£o.

---


### INTERFACE PRODUTO

```java
package refatoracao.estudos.solid.dependency.inversion.principle;

public interface Produto {

	void comentario();
	
	void amostra();
}
```

---

## D√öVIDAS DURANTE A AULA.

### D√öVIDA 1: Quando livro implementa publicao, automaticamente prateleira implementa tambem ?

---

### ‚úÖ Explicando com clareza: üèÜ

Quando voc√™ faz isso:

```java
public class Livro implements Publicacao {
    // implementa√ß√£o dos m√©todos da interface
}

```

- A classe `Livro` **se compromete** a implementar os m√©todos definidos pela interface `Publicacao`.
- Isso significa que qualquer objeto do tipo `Livro` **pode ser tratado como um `Publicacao`**.

---

### üß† Mas o que acontece em `Prateleira`?

```java
public class Prateleira {
    private final Publicacao publicacao;

    public Prateleira(Publicacao publicacao) {
        this.publicacao = publicacao;
    }
}

```

- Aqui, a `Prateleira` **usa/composi√ß√£o**: ela **recebe** (ou armazena) uma inst√¢ncia de `Publicacao`.
- Mas ela **n√£o implementa** a interface `Publicacao`, a menos que voc√™ diga explicitamente:

```java
public class Prateleira implements Publicacao {
    // Agora voc√™ teria que implementar todos os m√©todos de Publicacao
}

```

---

### üéØ Analogia simples:

- **Livro** √© como um *funcion√°rio* que assina um contrato (`Publicacao`) e promete seguir regras.
- **Prateleira** √© como um *departamento* que contrata esse funcion√°rio, mas o departamento **n√£o est√° vinculado ao contrato**, apenas o utiliza.
- Para o departamento (Prateleira) seguir o contrato (`Publicacao`), ele teria que assin√°-lo tamb√©m (fazer `implements Publicacao`).

---

### ‚úîÔ∏è Em resumo

| Situa√ß√£o | Implementa a interface? | Observa√ß√µes |
| --- | --- | --- |
| `Livro implements Publicacao` | ‚úÖ Sim | Livro deve implementar todos os m√©todos da interface |
| `Prateleira` recebe `Publicacao` como depend√™ncia | ‚ùå N√£o | Ela usa uma implementa√ß√£o de `Publicacao`, mas **n√£o a implementa** |
| `Prateleira implements Publicacao` | ‚úÖ S√≥ se voc√™ declarar explicitamente | Teria que implementar os m√©todos tamb√©m |

### D√öVIDA 2: Na minha classe prateleira, est√° ocorrendo DIP?

---

### üìå Princ√≠pio da Invers√£o de Depend√™ncia (DIP) ‚Äî Relembrando üèÜ

> ‚ÄúM√≥dulos de alto n√≠vel n√£o devem depender de m√≥dulos de baixo n√≠vel. Ambos devem depender de abstra√ß√µes.‚Äù
> 

Ou seja:

- **C√≥digo de alto n√≠vel** (como `Prateleira`) deve depender de uma **interface**, n√£o de uma implementa√ß√£o concreta como `Livro`.
- A **interface (abstra√ß√£o)** define o que deve ser feito.
- As **implementa√ß√µes** (como `Livro`, `Revista`, etc.) definem **como** isso ser√° feito.

---

### ‚úÖ Aplica√ß√£o da DIP neste c√≥digo

```java
public class Prateleira {
    private final Publicacao publicacao;

    public Prateleira(Publicacao publicacao) {
        this.publicacao = publicacao;
    }

    public void addLivro() {
        System.out.println("Publica√ß√£o adicionada √† prateleira.");
    }

    public void customizarComentarios() {
        publicacao.comentarioLivro(); // agora √© uma abstra√ß√£o
        System.out.println("Coment√°rios personalizados.");
    }
}

```

### O que est√° correto aqui:

| Elemento | Por que est√° certo? |
| --- | --- |
| `publicacao` √© do tipo `Publicacao` (uma **interface** ou **classe abstrata**) | ‚úîÔ∏è A classe depende de uma abstra√ß√£o, n√£o de uma implementa√ß√£o concreta |
| O objeto real (ex: `Livro`) √© passado via construtor | ‚úîÔ∏è Isso permite usar diferentes implementa√ß√µes de `Publicacao` sem mudar o c√≥digo de `Prateleira` |
| A classe `Prateleira` n√£o precisa saber se √© um `Livro`, `Revista`, etc. | ‚úîÔ∏è Isso reduz o acoplamento e segue o DIP |

---

### üìò Exemplo para visualizar o uso:

```java
public interface Publicacao {
    void comentarioLivro();
}

public class Livro implements Publicacao {
    public void comentarioLivro() {
        System.out.println("Coment√°rio do livro.");
    }
}

public class Revista implements Publicacao {
    public void comentarioLivro() {
        System.out.println("Coment√°rio da revista.");
    }
}

public class Main {
    public static void main(String[] args) {
        Publicacao livro = new Livro();
        Prateleira prateleira = new Prateleira(livro);
        prateleira.customizarComentarios();

        Publicacao revista = new Revista();
        Prateleira outraPrateleira = new Prateleira(revista);
        outraPrateleira.customizarComentarios();
    }
}

```

‚úÖ Esse c√≥digo permite trocar `Livro` por `Revista` ou qualquer outra `Publicacao` **sem alterar a l√≥gica da `Prateleira`**, cumprindo a **invers√£o de depend√™ncia**.

---

### ‚úÖ Conclus√£o

> ‚úîÔ∏è Sim, sua classe Prateleira est√° aplicando corretamente o DIP, porque depende de uma abstra√ß√£o (Publicacao) e n√£o de uma implementa√ß√£o concreta (Livro).
> 

### D√öVIDA 3: ENT√ÉO N√ÉO √â NECESS√ÅRIO UTILIZAR O IMPLEMENTS NA CLASSE?

üèÜ Exatamente! ‚úÖ **N√£o √© necess√°rio usar `implements` na classe `Prateleira` nesse caso.**

---

### üìå Por qu√™?

A palavra-chave `implements` s√≥ √© usada quando **uma classe precisa seguir um contrato definido por uma interface**, ou seja, **quando ela mesma deve oferecer os m√©todos definidos pela interface**.

No seu caso:

```java
public class Prateleira {
    private final Publicacao publicacao;
    ...
}

```

- A classe `Prateleira` **n√£o est√° tentando ser uma `Publicacao`**.
- Ela **usa/composi√ß√£o** de um objeto que implementa a interface `Publicacao`.
- Portanto, **ela s√≥ depende dessa abstra√ß√£o**, e n√£o precisa implement√°-la.

---

### ‚úÖ Correto:

```java
public class Prateleira {
    private final Publicacao publicacao;

    public Prateleira(Publicacao publicacao) {
        this.publicacao = publicacao;
    }

    public void customizarComentarios() {
        publicacao.comentarioLivro();
    }
}

```

---

### ‚ùå Desnecess√°rio:

```java
public class Prateleira implements Publicacao {
    ...
}

```

Esse s√≥ seria necess√°rio **se `Prateleira` tamb√©m quisesse se comportar como uma `Publicacao`**, ou seja, **se ela pr√≥pria quisesse implementar `comentarioLivro()`** ‚Äî o que **n√£o faz sentido no seu contexto atual**.

---

### ‚úÖ Em resumo:

| Situa√ß√£o | Usa `implements`? | Por qu√™? |
| --- | --- | --- |
| `Prateleira` **usa** `Publicacao` | ‚ùå N√£o | Est√° apenas **consumindo** a interface via composi√ß√£o |
| `Livro` **√©** uma `Publicacao` | ‚úÖ Sim | Est√° **implementando** os m√©todos da interface |
| `Prateleira` precisa agir como uma `Publicacao` | ‚úÖ Somente se necess√°rio | S√≥ se ela mesma tiver que ser usada como uma `Publicacao` |

---


### D√öVIDA 4: O QUE SIGNIFICA ‚Äúo que √© Ela usa/composi√ß√£o de um objeto que implementa a interface Publicacao.? pode usar livro como exemplo‚Äù?

üèÜ Claro! Vamos explicar isso de forma bem direta e com exemplo usando a classe `Livro`.

---

### üìò O que significa:

> "Ela usa/composi√ß√£o de um objeto que implementa a interface Publicacao"?
> 

Significa que a classe `Prateleira` **n√£o implementa a interface `Publicacao` diretamente**, mas **possui um atributo que √© uma inst√¢ncia de uma classe que implementa essa interface** ‚Äî ou seja, **ela usa a interface indiretamente por meio de composi√ß√£o**.

---

### üì¶ Composi√ß√£o ‚Äî explicando o termo:

**Composi√ß√£o** √© quando uma classe **tem** outra classe como parte de sua estrutura, geralmente como um atributo.

√â diferente de **heran√ßa**, onde uma classe **√© um tipo de** outra.

---

### üëá Exemplo com `Livro` e `Publicacao`

### Interface `Publicacao`:

```java
public interface Publicacao {
    void comentarioLivro();
}

```

### Classe `Livro` que implementa a interface:

```java
public class Livro implements Publicacao {
    @Override
    public void comentarioLivro() {
        System.out.println("Coment√°rio do livro.");
    }
}

```

### Classe `Prateleira` que **usa/composi√ß√£o**:

```java
public class Prateleira {
    private final Publicacao publicacao; // composi√ß√£o: tem uma Publicacao

    public Prateleira(Publicacao publicacao) {
        this.publicacao = publicacao;
    }

    public void customizarComentarios() {
        publicacao.comentarioLivro(); // usa o comportamento da interface
        System.out.println("Coment√°rios personalizados.");
    }
}

```

### Classe principal que junta tudo:

```java
public class Main {
    public static void main(String[] args) {
        Livro livro = new Livro(); // Livro IMPLEMENTA Publicacao
        Prateleira prateleira = new Prateleira(livro); // Prateleira USA livro

        prateleira.customizarComentarios();
    }
}

```

---

### üß† Em resumo:

- `Livro` **implementa** a interface `Publicacao` ‚Üí ele fornece o comportamento definido.
- `Prateleira` **usa/composi√ß√£o**: ela **tem um atributo** do tipo `Publicacao` (pode ser `Livro`, `Revista`, etc.).
- `Prateleira` **chama m√©todos da interface** por meio desse atributo, sem saber que √© especificamente um `Livro`.

---

### üéØ Vantagens de usar composi√ß√£o com abstra√ß√£o (como voc√™ fez):

- Permite mudar a implementa√ß√£o (usar `Livro`, `Revista`, `Artigo`, etc.) sem alterar a `Prateleira`.
- Reduz o acoplamento.
- Segue o DIP (Princ√≠pio da Invers√£o de Depend√™ncia).

---


### D√öVIDA 5: se √© uma instancia, por que o operador new n√£o esta sendo utilizado?

üèÜ Excelente pergunta! E voc√™ est√° pensando da maneira certa. Vamos esclarecer isso com cuidado:

---

### ‚úÖ Resposta curta:

O operador `new` **√© usado sim ‚Äî mas n√£o dentro da classe `Prateleira`**. Ele √© usado **fora dela**, no c√≥digo que **instancia** a `Prateleira`, geralmente na classe `Main` ou em algum outro ponto de cria√ß√£o do objeto.

---

### üìå Vamos revisar com exemplo:

### Classe `Prateleira`:

```java
public class Prateleira {
    private final Publicacao publicacao;

    public Prateleira(Publicacao publicacao) {
        this.publicacao = publicacao;
    }

    public void customizarComentarios() {
        publicacao.comentarioLivro();
    }
}

```

üëâ Aqui, `Prateleira` **n√£o cria** (`new`) o `Livro`. Ela **recebe** um `Publicacao` pronto via construtor.

---

### Classe `Livro`:

```java
public class Livro implements Publicacao {
    public void comentarioLivro() {
        System.out.println("Coment√°rio do livro.");
    }
}

```

---

### Onde o `new` aparece? Aqui:

```java
public class Main {
    public static void main(String[] args) {
        Publicacao livro = new Livro(); // AQUI est√° o new
        Prateleira prateleira = new Prateleira(livro); // Inje√ß√£o via construtor

        prateleira.customizarComentarios();
    }
}

```

üü¢ O `new Livro()` **cria a inst√¢ncia concreta** de `Livro`, que √© passada para a `Prateleira`.

---

### üß† Isso √© um padr√£o de **inje√ß√£o de depend√™ncia**:

- A `Prateleira` **n√£o deve saber** como criar um `Livro` (nem usar `new Livro()`).
- Algu√©m de fora (como a classe `Main`, um controller, ou um framework como Spring) √© que **faz a inje√ß√£o da depend√™ncia**.
- Isso segue o **DIP (Dependency Inversion Principle)** e o princ√≠pio da **responsabilidade √∫nica (SRP)**.

---

### üî• Por que isso √© bom?

Se a `Prateleira` fizesse isso:

```java
public class Prateleira {
    private final Publicacao publicacao = new Livro(); // acoplamento forte üò¨
}

```

Ela estaria **acoplada √† implementa√ß√£o `Livro`** para sempre ‚Äî n√£o daria pra usar uma `Revista` ou um `Artigo` sem mudar o c√≥digo da classe.

---

### ‚úÖ Conclus√£o

Voc√™ n√£o v√™ o `new` dentro da `Prateleira` porque **ela n√£o cria a depend√™ncia ‚Äî ela recebe pronta**. Isso √© um sinal de **bom design orientado a objetos** e pr√°tica comum em **inje√ß√£o de depend√™ncia**.


### D√öVIDA 6: O que seria criar a depend√™ncia?


---

### ‚úÖ O que significa **"criar a depend√™ncia"**? üèÜ

**Criar a depend√™ncia** significa que uma classe **instancia diretamente** outra classe usando o operador `new`.

Ou seja, ela **√© respons√°vel por construir o objeto que ela mesma vai usar**.

---

### üì¶ Exemplo ‚Äî Criando a depend√™ncia (acoplamento forte):

```java
public class Prateleira {

    private final Livro livro;

    public Prateleira() {
        this.livro = new Livro(); // Aqui est√° criando a depend√™ncia diretamente
    }

    public void customizarComentarios() {
        livro.comentarioLivro();
    }
}

```

üî¥ **Problema**: Agora a `Prateleira` est√° **fortemente acoplada** √† classe `Livro`.

- Voc√™ **n√£o pode** trocar o `Livro` por outro tipo de publica√ß√£o (ex: `Revista`) sem alterar o c√≥digo da classe.
- Isso **viola o DIP** e **torna o c√≥digo menos flex√≠vel/test√°vel**.

---

### ‚úÖ Em vez disso, usamos **inje√ß√£o de depend√™ncia**:

```java
public class Prateleira {

    private final Publicacao publicacao;

    public Prateleira(Publicacao publicacao) {
        this.publicacao = publicacao; // Recebe a depend√™ncia de fora
    }

    public void customizarComentarios() {
        publicacao.comentarioLivro();
    }
}

```

E em outro lugar (como na classe `Main`), **criamos a depend√™ncia** e passamos:

```java
Publicacao livro = new Livro(); // Aqui criamos a depend√™ncia
Prateleira prateleira = new Prateleira(livro); // E injetamos

```

---

### üß† Ent√£o em resumo:

| Termo | Significado |
| --- | --- |
| **Criar a depend√™ncia** | Usar `new` dentro da pr√≥pria classe para instanciar outra classe que ela usa |
| **Inje√ß√£o de depend√™ncia** | Receber a inst√¢ncia de outra classe j√° criada (geralmente por um terceiro ou framework) |

---

### üéØ Por que evitar criar depend√™ncias internamente?

- Para **reduzir o acoplamento**
- Para **facilitar testes** (pode passar mocks ou dubl√™s)
- Para **aumentar a flexibilidade** (mudar a implementa√ß√£o sem tocar no c√≥digo)
- Para **seguir o DIP (Dependency Inversion Principle)**

---

